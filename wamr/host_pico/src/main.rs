//! Blinks the LED on a Pico board
//!
//! This will blink an LED attached to GP25, which is the pin the Pico uses for the on-board LED.
#![no_std]
#![no_main]

use core::ffi::c_void;
use defmt::*;
use defmt_rtt as _;
use once_cell::sync::Lazy;
use panic_probe as _;

use wamr_rust_sdk::{
    function::Function, instance::Instance, module::Module, runtime::Runtime, value::WasmValue,
    wasi_context::WasiCtxBuilder,
};

// Time handling traits:
use fugit::RateExtU32;

use embedded_hal::i2c::I2c;
// use embedded_hal::blocking::i2c::Write;

// use rp_pico;
use rp_pico::entry;
use rp_pico::hal::{
    clocks::{init_clocks_and_plls, Clock},
    gpio, pac,
    sio::Sio,
    watchdog::Watchdog,
    I2C,
};

extern crate alloc;
use alloc::vec;
use alloc::vec::Vec;

static mut I2C_VEC: once_cell::sync::Lazy<
    Vec<
        I2C<
            pac::I2C0,
            (
                gpio::Pin<gpio::bank0::Gpio4, gpio::FunctionI2c, gpio::PullUp>,
                gpio::Pin<gpio::bank0::Gpio5, gpio::FunctionI2c, gpio::PullUp>,
            ),
        >,
    >,
> = Lazy::new(|| vec![]);

extern "C" fn host_i2c_write(_exec_env: u16, slave_address: u16, data: u8) {
    let slice = &[data];
    unsafe {
        let _ = I2C_VEC[0].write(slave_address, slice);
    };
}

#[entry]
fn main() -> ! {
    info!("Program start");
    let mut pac = pac::Peripherals::take().unwrap();
    let core = pac::CorePeripherals::take().unwrap();
    let mut watchdog = Watchdog::new(pac.WATCHDOG);
    let sio = Sio::new(pac.SIO);

    // External high-speed crystal on the pico board is 12Mhz
    let external_xtal_freq_hz = 12_000_000u32;
    let clocks = init_clocks_and_plls(
        external_xtal_freq_hz,
        pac.XOSC,
        pac.CLOCKS,
        pac.PLL_SYS,
        pac.PLL_USB,
        &mut pac.RESETS,
        &mut watchdog,
    )
    .ok()
    .unwrap();

    let mut delay = cortex_m::delay::Delay::new(core.SYST, clocks.system_clock.freq().to_Hz());

    let pins = rp_pico::Pins::new(
        pac.IO_BANK0,
        pac.PADS_BANK0,
        sio.gpio_bank0,
        &mut pac.RESETS,
    );

    // Configure two pins as being I²C, not GPIO
    let sda_pin: gpio::Pin<_, gpio::FunctionI2C, _> = pins.gpio4.reconfigure();
    let scl_pin: gpio::Pin<_, gpio::FunctionI2C, _> = pins.gpio5.reconfigure();

    // Create the I²C driver, using the two pre-configured pins. This will fail
    // at compile time if the pins are in the wrong mode, or if this I²C
    // peripheral isn't available on these pins!
    let i2c = I2C::i2c0(
        pac.I2C0,
        sda_pin,
        scl_pin,
        400.kHz(),
        &mut pac.RESETS,
        &clocks.system_clock,
    );

    unsafe {
        I2C_VEC.push(i2c);
    }

    // WAMR stuff
    let runtime = Runtime::builder()
        .use_system_allocator()
        .register_host_function("host_i2c_write", host_i2c_write as *mut c_void)
        .build()
        .unwrap();

    // let mut d = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    // d.push("guest.wasm");
    // let mut module = Module::from_file(&runtime, "/guest.wasm").unwrap();
    let binary = vec![
        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x10, 0x03, 0x60, 0x02, 0x7f, 0x7f,
        0x00, 0x60, 0x00, 0x00, 0x60, 0x04, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x02, 0x17, 0x01, 0x04,
        0x68, 0x6f, 0x73, 0x74, 0x0e, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x69, 0x32, 0x63, 0x5f, 0x77,
        0x72, 0x69, 0x74, 0x65, 0x00, 0x00, 0x03, 0x03, 0x02, 0x01, 0x02, 0x05, 0x03, 0x01, 0x00,
        0x01, 0x06, 0x07, 0x01, 0x7f, 0x01, 0x41, 0x80, 0x20, 0x0b, 0x07, 0x1a, 0x03, 0x06, 0x6d,
        0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00, 0x05, 0x73, 0x65, 0x74, 0x75, 0x70, 0x00, 0x01,
        0x05, 0x77, 0x72, 0x69, 0x74, 0x65, 0x00, 0x02, 0x0a, 0xff, 0x01, 0x02, 0x17, 0x00, 0x41,
        0x24, 0x41, 0x81, 0x01, 0x10, 0x80, 0x80, 0x80, 0x80, 0x00, 0x41, 0x24, 0x41, 0x01, 0x10,
        0x80, 0x80, 0x80, 0x80, 0x00, 0x0b, 0xe4, 0x01, 0x01, 0x01, 0x7f, 0x23, 0x80, 0x80, 0x80,
        0x80, 0x00, 0x41, 0x10, 0x6b, 0x22, 0x04, 0x24, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20, 0x04,
        0x41, 0xff, 0xde, 0x01, 0x3b, 0x00, 0x0e, 0x20, 0x04, 0x42, 0xbf, 0x8c, 0xec, 0xfa, 0xe4,
        0xac, 0xdb, 0xbe, 0x07, 0x37, 0x00, 0x06, 0x41, 0x34, 0x20, 0x04, 0x41, 0x06, 0x6a, 0x20,
        0x00, 0x41, 0x50, 0x6a, 0x41, 0x0a, 0x70, 0x6a, 0x2d, 0x00, 0x00, 0x10, 0x80, 0x80, 0x80,
        0x80, 0x00, 0x20, 0x04, 0x41, 0xff, 0xde, 0x01, 0x3b, 0x00, 0x0e, 0x20, 0x04, 0x42, 0xbf,
        0x8c, 0xec, 0xfa, 0xe4, 0xac, 0xdb, 0xbe, 0x07, 0x37, 0x00, 0x06, 0x41, 0x35, 0x20, 0x04,
        0x41, 0x06, 0x6a, 0x20, 0x01, 0x41, 0x50, 0x6a, 0x41, 0x0a, 0x70, 0x6a, 0x2d, 0x00, 0x00,
        0x10, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20, 0x04, 0x41, 0xff, 0xde, 0x01, 0x3b, 0x00, 0x0e,
        0x20, 0x04, 0x42, 0xbf, 0x8c, 0xec, 0xfa, 0xe4, 0xac, 0xdb, 0xbe, 0x07, 0x37, 0x00, 0x06,
        0x41, 0x36, 0x20, 0x04, 0x41, 0x06, 0x6a, 0x20, 0x02, 0x41, 0x50, 0x6a, 0x41, 0x0a, 0x70,
        0x6a, 0x2d, 0x00, 0x00, 0x10, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20, 0x04, 0x41, 0xff, 0xde,
        0x01, 0x3b, 0x00, 0x0e, 0x20, 0x04, 0x42, 0xbf, 0x8c, 0xec, 0xfa, 0xe4, 0xac, 0xdb, 0xbe,
        0x07, 0x37, 0x00, 0x06, 0x41, 0x37, 0x20, 0x04, 0x41, 0x06, 0x6a, 0x20, 0x03, 0x41, 0x50,
        0x6a, 0x41, 0x0a, 0x70, 0x6a, 0x2d, 0x00, 0x00, 0x10, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20,
        0x04, 0x41, 0x10, 0x6a, 0x24, 0x80, 0x80, 0x80, 0x80, 0x00, 0x0b,
    ];
    let binary = binary.into_iter().map(|c| c as u8).collect::<Vec<u8>>();

    let wasi_ctx = WasiCtxBuilder::new()
        .set_pre_open_path(vec!["."], vec![])
        .build();

    let module = Module::from_buf(&runtime, &binary, "guest");
    let mut module = module.unwrap();
    module.set_wasi_context(wasi_ctx);

    let instance = Instance::new(&runtime, &module, 1024 * 64).unwrap();

    let function = Function::find_export_func(&instance, "setup").unwrap();
    function.call(&instance, &vec![WasmValue::Void]).unwrap();

    let function = Function::find_export_func(&instance, "write").unwrap();

    let mut ctr: [u8; 4] = [0, 0, 0, 0];
    loop {
        delay.delay_ms(500);
        let params = ctr.iter().map(|b| WasmValue::I32(i32::from(*b))).collect();

        function.call(&instance, &params).unwrap();

        ctr = match ctr {
            [a, b, c, 9] => [a, b, c + 1, 0],
            [a, b, 9, d] => [a, b + 1, 0, d],
            [a, 9, c, d] => [a + 1, 0, c, d],
            [9, b, c, d] => [0, b, c, d],
            [a, b, c, d] => [a, b, c, d + 1],
        };
    }
}
